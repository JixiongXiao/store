v-model和.sync的差别 / 双向数据绑定的原理 https://juejin.cn/post/7020248745002401805#heading-0

v-model的本质是父组件引用子组件时往子组件的'value'中传递参数，并且监听input事件
<Child :value="num" @input='val=>num=val'>
子组件内部的props必须声明一个变量，名为value，并且emit一个input事件，value作为参数
this.$emit('input',this.value)
.sync的本质是emit和v-on的缩写
父组件使用调用子组件时传值可以加上.sync修饰符
<Child :a.sync="num" .b.sync="num2"></Child>
子组件接收参数时不再像v-model一样声明value,而是直接在props声明相应的变量名a和b
但是子组件在数据发生改变时必须emit一个事件'update:变量名'的事件，并且把该值作为参数
父组件有.sync修饰符时会自动监听这个update事件
this.$emit('update:a',this.a)
this.$emit('update:b',this.b)

router中hash模式和history模式的区别 https://juejin.cn/post/6993840419041706014

*hash模式特点:
hash模式会在url后加上#，正常情况下我们进入单应用页面时会把所有需要的页面资源
全部下载下来，后续的页面跳转就是改变#后面的地址，然后触发onHashChange事件进行跳转，
这个过程是纯客户端的跳转，不会再从服务端请求资源，页面所需的数据可以在生命周期中请求
*history模式特点:
history也允许开发者更改浏览器的url而不重新向服务端发送请求，只是进行客户端的页面跳转
通过history.pushstate和history.replaceState来实现
*两者的区别？为什么history模式下服务端要做适配？
在使用hash模式时虽然改变了url，但是不包含在http请求中，不会影响服务端，改变hash并没有
真正改变url，假设我们服务端配置了nginx，用户刷新页面时获得的还是相同的url，页面可以顺利刷新
如果是用户在当前用histroy模式操作切换页面的话，URL会被改变、
浏览器不会刷新页面也不会往服务端发请求，但会触发代码内的监听事件从而改变页面内容，
所以无需用到服务器也可以自由切换页面了。但是这里有个很核心的点就是URL会改变，即有新的URL诞生，
所以如果这时用户主动刷新页面（F5），浏览器发送给服务端的是新的URL，所以服务端要做适配，
配置一个合理的规则让这些URL返回的都是同一个index.html,否则会报错,
所以说history模式需要通过服务端来允许地址可访问

箭头函数和普通函数区别

箭头函数不会创建自己的this,所以它没有自己的this,它只会在自己作用域的上一层继承this。
所以箭头函数中的this的指向在它在定义时一家确定了，之后不会改变。
call()、apply()、bind()等方法不能改变箭头函数中的this指向。
箭头函数不能作为构造函数使用。没有自己的arguments，没有prototype

map和set的区别 https://juejin.cn/post/7064479924757168165
map的数据结构是键值对，key可以是字符串也可以是个对象
用法 map.set(key,value), map.has(key)/true-false, map.delete(key), map.delete(key), map.get(key)
set类似数组，且内部的值都是唯一的 const arr2 = [...new Set(arr)]是最快的去重方法
用法 set.add(value), set.delete(value), set.has(value)
map和set都不允许key重复，set的value就是key，value是唯一的
map是二维数组，set是一维数组

forEach和map的区别
forEach方法没有返回值，map会返回一个处理后的值的数组
如果是只是为了遍历原数组，应该使用foreach，如果是为了处理原数组，应该用map

localStorage  sessionStorage  cookies 有什么区别? https://juejin.cn/post/6844903516826255373
cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效,可存放4kb左右信息
localStorage：除非被手动清除，否则将会永久保存。可存放5MB
sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。可存放5MB
cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信

web同源跨域，xss跨站脚本攻击，sql注入，csrf攻击 https://juejin.cn/post/7096701608456617997

同源和跨域CORS，CSP
如果两个url的协议，域名和端口相同，那么这两个url同源，
同源的url可以互相操作dom，互相读取cookie，localstorage，同源策略限制了不同源站点之间的http网络请求
通过跨域资源共享CORS机制解决这个问题，并且引入CSP机制来限制其自由，防止xss攻击
浏览器请求第三方资源后，所以为了安全，浏览器中引入了内容安全策略，称为 CSP。
CSP全称 content-sercurity-policy，在http响应头，告诉浏览器哪些js和图片资源可以加载，有什么规则
