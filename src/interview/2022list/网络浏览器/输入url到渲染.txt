整体步骤 https://juejin.cn/post/6844903717259444232
https://juejin.cn/post/7103448692866154510
1 URL解析【识别URL】
2 检查缓存 【强缓存，协商缓存，本地存储
3 DNS服务器解析 【域名解析：根据域名解析出服务器的外网IP】 没有缓存，需要往服务器发送请求，首先就是要找到服务器的位置就是DNS解析
4 TCP的三次握手 【建立客户端和服务器之间的网络通道】
5 基于HTTP/HTTPS 等传输协议，实现客户端和服务器之间的信息通信
6 TCP的四次挥手 【把建立好的网络通道释放掉】
7 客户端渲染 【呈现出页面效果】
*如果是第一次访问，那么就没有缓存可言，所有的流程都会走一遍

1 什么是url
url的组成
协议 域名 主机 端口号 路径 文件名

2 DNS域名解析
浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，
浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器

3 TCP的3次握手
目的:三次握手的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。"
为什么？
三次握手是能保证client和server建立起有效通讯的最低次数
有两种情况可举例：
* client发送的第一个连接请求报文没有丢失，而是因为网络问题滞留了，延迟到连接已经释放后才到达server，
  此时此刻server不知道这条报文已经失效，误认为是client重新发送了一次连接请求，于是向client发送了确认报文同意建立连接
  如果不采用三次握手，那么这个连接就建立了，但是client并没有发送新的建立请求的报文，所以也不会理会server发送的确认报文
  而server一直在等待client发过来的数据，这就导致server很多资源被浪费了
* client发送了报文，server确认了，返回了确认建立连接的报文，但是这条报文也因为网络问题滞留了，也会导致上述情况

4 TCP的4次挥手
发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。
(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)

被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。
(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)

被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。
(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)

发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。
(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)

//浏览器渲染

/*
                             DOM
                             ↓
HTML ---> HTML Parser --->   DOM TREE           Layout
                             ↓                    ↑↓
                             Attachment  ---> Render Tree ---> Painting ----> Display
                             ↑
 Style  --> Css Parser --->  Style Rules
Sheets

    浏览器拿到代码后 
1.第一件事：在内存条中开辟一块栈内存，用来给代码执行提供环境；同时分配一个主线程去解析和执行代码（所以JS是单线程）
当浏览器遇到link/script/img等请求后，会开辟新的线程去加载文件(所以浏览器是多线程的)
此时任务队列会加载CSS,JS，IMG文件等等，但是主线程依然从上到下执行html文件，第一次渲染完毕，只生成DOM树
   构建DOM的大致过程如下：
      通过网络获取字节流和字符；
      对字符序列进行分词操作，得到一个个token；
      根据token序列分析语法，得到一个个节点node；
      根据node序列，分析并构建DOM树。

主线程生成DOM树后，开始从任务队列获取其他任务，解析CSS 借助DOM树生成CSSOM (CSS object model CSS对象模型) 
https://www.jianshu.com/p/7c3e2493c7a7 什么是CSSOM 

2.浏览器会结合DOM TREE和 CSSOM 生成Render Tree 渲染树

3.Layout(回流) 根据生成的渲染树 计算她们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流

4.Painting(重绘) 根据渲染树以及回流得到的几何信息，得到节点的绝对像素

5.Display 将像素发给GPU 展示在页面上


页面渲染阶段：
1.第一件事：在内存条中开辟一块栈内存，用来给代码执行提供环境；同时分配一个主线程去解析和执行HTML文件（所以JS是单线程）
当浏览器遇到link/script/img等请求后，会开辟新的线程去加载文件(所以浏览器是多线程的)
此时任务队列会加载CSS,JS，IMG文件等等，但是主线程依然从上到下执行html文件，第一次渲染完毕，只生成DOM树
首先是通过HTML文件构建DOM树，因为浏览器是无法直接理解和使用HTML文件的，
然后是把css文件获得浏览器可以理解的结构styleSheets，然后借助DOM树生成CSS object model，css对象模型，这个阶段目的是为了计算每个DOM的具体样式
获得了DOM树和CSS object model之后开始进行layout的步骤，计算节点的坐标，
这个过程会生成layout tree 和layer tree，因为html元素也会按照优先级分布在2维平面的z轴上也就是z-index
然后开始进行绘制，绘制的过程其实也就是整个页面被栅格化的过程，也就是计算像素点，
这个过程其实是由渲染引擎完成的，所以这个过程不会影响主线程的执行
最后交由浏览器展示出来