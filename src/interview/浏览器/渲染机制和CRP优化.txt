视频：珠峰课时40-41

CRP: critical rendering path 关键渲染路径
围绕渲染机制和步骤，去详细地进行每一步的优化，以此来提高页面的渲染速度和运行性能

浏览器的渲染机制：（关于http请求和http响应阶段请看其他文件）

1.从服务i去基于http网络请求回来的数据
  · 是十六进制的文件流
  · 浏览器把它解析为字符串(HTML字符串)
  · 按照W3C规则 识别成为一个个的节点（html词法解析）
  · 最后生成DOM树
      构建DOM的大致过程如下：
      通过网络获取字节流和字符；
      对字符序列进行分词操作，得到一个个token；【词法解析】
      根据token序列分析语法，得到一个个节点node；【语法解析】
      根据node序列，分析并构建DOM树。
   · DOM TREE 就是描述HTML 节点和节点之间关系

2.访问页面，首先请求回来的是一个HTML文档，浏览器开始自上而下渲染
  · 进程：一般指一个程序（浏览器打开一个页面，相当于打开了一个进程）
  · 线程：进程中，具体去执行业务的东西叫线程，一个线程只能同时干一件事
          一个进程中，可能包含一个到多个线程

   * 同步异步编程相关知识：
    同步编程：一边是指只有一个线程去处理业务，自上而下
    异步编程：1 多线程异步编程 2 单线程异步编程(JS是eventQueue+EventLoop机制完成单线程异步编程的)

  · 浏览器是可以开辟多个进程和线程的
     · GUI渲染线程：渲染页面
     · JS引擎线程：渲染JS代码
     · HTTP网络线程：可以开辟多个，从服务器获取数据
     · 定时器监听线程
     · DOM监听线程

  · 渲染页面过程当中
    ·关于CSS  
    · 遇到style内嵌样式，GUI直接渲染
       · -> CSS代码量少，用内嵌，避免HTTP请求 （性能优化）百度页面就是用内嵌，移动端开发一般也用内嵌
       · -> CSS代码量大，用内嵌一方面影响HTML拉去速度，也不利于代码维护，此时用外链方式比较好
    · 遇到link，浏览器会开辟一个HTTP线程去请求资源文件，同时GUI继续向下渲染【异步】
       · 浏览器同时发送HTTP请求是有数量限制的(谷歌5~7个)
       · 超过限制需要排队等待
       · -> 因此HTTP请求越少越好（性能优化）
    · 遇到@import，浏览器开辟HTTP线程去请求资源文件，但是GUI线程会暂停(导入式样式会阻碍GUI渲染)【同步】 
       · -> 因此真是项目中应该避免使用import (性能优化)
    
    · 遇到 <script src="">，会阻碍GUI渲染
       · defer
       · async
    渲染页面过程优化方案：
      1 标签语义化和避免深层次嵌套[层级过深影响DOM树建立速度]
      2 CSS选择器渲染是从右到左 [ a{} 的性能比 #box .btn a{} 高，因为CSS选择器会从右边开始依次解析，所以避免嵌套太深 ]
      3 尽早把CSS下载到客户端（充分利用HTTP多请求并发机制 link）
      4 避免阻塞的JS加载 async 异步加载，加载完后立即暂停GUI，然后执行JS文档，
                              如果js文件之间有依赖关系，async可能会导致依赖无效，因为哪个js先加载完就先执行哪个。
                        defer 异步加载，等GUI渲染完HTML之后，再执行JS文档 多个文档的话会等所有文档都加载完才执行
                        放到底部
      真实项目开发种中，一般把link放在页面头部，是为了再没有渲染DOM的时候就通知HTTP去请求CSS，这样DOM渲染结束，CSS也可以请求结束
      这样可以更有效利用时间，提高页面渲染速度。一般把JS放在页面底部，防止阻碍GUI渲染                 

3.总流程
  ·layout 就是计算渲染树在设备视口viewpoint内的确切位置和大小[布局layout/重排reflow]
  ·根据渲染树以及回流得到的几何信息，获得节点的绝对像素[绘制painting] 
   · DOM Tree生成后 (DOMContentLoaded事件触发) -> [执行JS]？ -> CSSOM Tree  
     -> render tree 渲染树 [浏览器是按照这个树绘制页面的] -> layout 布局运算[回流/重排] 
     -> painting [重绘] {分层绘制} ->display   

  · 回流：元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染
     如添加或删除可见的DOM元素；元素位置，尺寸，内容（文本变化或者图片被不同尺寸图片代替）发生变化；页面一开始的渲染（这个无法避免）；
     回流是根据视窗的大小计算元素的位置和大小的，浏览器窗口尺寸变化也会引发回流
    注意：回流一定会触发重绘，重绘不一定会回流      

  · 重绘：元素样式的改变（宽高，大小，位置等不变）
     如 outline, visibility, color, background-color  