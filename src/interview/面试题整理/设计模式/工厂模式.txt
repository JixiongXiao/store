个人笔记：
我觉得工厂模式的核心思想是[一个工厂，里面很多条生产线，我们放入不同的生产原料，根据不同原料运行不同加工线，加工出不同的产品]
假设一个场景，我们需要创建一个对象。我们把对象创建的逻辑封装在一个函数内，那么这个函数就可以成为工厂。
工厂模式根据抽象程度不同可以分为简单工厂，工厂方法和抽象工厂。
我们创建一个函数作为工厂，函数可以接收一个参数，这个参数就是我所说的原料，
函数内部判断这个参数的类型，根据逻辑判断，去运行工厂内部的不同方法，从而生产出不同的实例。这就是最简单的工厂模式。
let  factory = function (role) {
function IronMan() {
    this.name ='Ironman',
}

function SpiderMan() {
    this.name = 'SpiderMan',
}

switch(role) {
    case 'iron':
    return new IronMan();
    break;
    case 'spider':
    return new SpiderMan();
    break;
    default:
    throw new Error('参数错误')
}
}
let ironman = factory('iron');
let spiderman = factory('spider');

笔记：
发现简单工厂模式存在一系列问题：

工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。

而工厂方法 factory method就解决了这个方法。工厂方法的特点在于，它把创建产品的过程推迟到了子类中，
我看有人用一句话总结是[将静态工厂里的工厂类用继承的方式细分]
我个人用通俗一点的方式去理解就是
[创建一个总工厂，总工厂识别原料种类，根据原料的总类发放到不同子工厂，子工厂根据不同的原料去不同的生产线生产]
当我们有新需求，我们只需要增加新的子工厂或者新的生产线就可以，而不需要对总工厂进行改造。
然后我的理解是当工厂的层级越来越高，那就会变成 abstract factory。 抽象工厂。
我个人理解就是围绕着一个总公司建立起一系列的分厂。